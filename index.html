<!-- index.html (Angepasst für Download von oben) -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Live Paket Visualisierung mit p5.js</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #download-button {
      position: absolute; bottom: 20px; left: 20px;
      padding: 12px 24px; background: #007bff; color: #fff;
      border: none; border-radius: 8px; font-size: 16px;
      cursor: pointer; z-index: 100;
    }
    #download-button:disabled { background: #555; cursor: not-allowed; }
  </style>
</head>
<body>
  <div id="network-info" style="position:absolute; left:20px; bottom:60px; color:#ccc; font-family:sans-serif; font-size:16px; z-index:101;"></div>
  <button id="download-button">Download starten</button>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof p5 === 'undefined') {
        document.body.innerHTML = '<h1 style="color:red;">Fehler: p5.js konnte nicht geladen werden.</h1>';
        return;
      }
      
      let strokes = [];
      let networkNodes = [];
      let networkEdges = [];
      let TRI_ROWS = 10; // Will be set dynamically

      function createTriangularNetwork() {
        networkNodes = [];
        networkEdges = [];
        TRI_ROWS = constrain(Math.round(height / 70), 7, 18);
        let totalRows = TRI_ROWS + 1; // Only one row above the screen, one at bottom
        let yTop = -height / (TRI_ROWS - 1); // one row above the screen
        let yBottom = height * 0.92;
        for (let r = 0; r < totalRows; r++) {
          let t = r / (totalRows - 1);
          let y = lerp(yTop, yBottom, t);
          let nodesInRow = (totalRows - r);
          let triangleWidth = map(width, 400, 1600, 0.6, 0.8, true) * width;
          let rowWidth = triangleWidth * (nodesInRow / totalRows);
          let xStart = width / 2 - rowWidth / 2;
          let xStep = rowWidth / (nodesInRow - 1 || 1);
          for (let c = 0; c < nodesInRow; c++) {
            let x = nodesInRow === 1 ? width / 2 : xStart + c * xStep;
            networkNodes.push({ x, y, r, c });
          }
        }
        // Randomized connections: each node connects to 1 or 2 random (but nearby) nodes in the row below
        for (let node of networkNodes) {
          if (node.r < totalRows - 1) {
            let belowRow = networkNodes.filter(n => n.r === node.r + 1);
            // Identify if node is leftmost or rightmost in its row
            let isLeftmost = node.c === 0;
            let isRightmost = node.c === (totalRows - node.r - 1);
            if (isLeftmost || isRightmost) {
              // Only connect to the single closest node below
              let closest = belowRow.reduce((best, n) => Math.abs(n.x - node.x) < Math.abs(best.x - node.x) ? n : best, belowRow[0]);
              networkEdges.push({ a: node, b: closest });
            } else {
              // Sort by distance, but add randomness
              let sorted = belowRow.slice().sort((a, b) => (Math.abs(a.x - node.x) + random(0, 60)) - (Math.abs(b.x - node.x) + random(0, 60)));
              let numConnections = random() < 0.7 ? 2 : 1; // 70% chance for 2, else 1
              let chosen = [];
              for (let i = 0; i < numConnections && i < sorted.length; i++) {
                if (random() < 0.9 || i === 0) { // favor closer nodes
                  chosen.push(sorted[i]);
                }
              }
              for (let target of chosen) {
                networkEdges.push({ a: node, b: target });
              }
            }
          }
        }
        // Ensure every node (except top row) has at least one connection to the row above
        for (let node of networkNodes) {
          if (node.r === 0) continue;
          let aboveRow = networkNodes.filter(n => n.r === node.r - 1);
          let hasConnection = networkEdges.some(e => e.b === node && aboveRow.includes(e.a));
          if (!hasConnection && aboveRow.length > 0) {
            // Add connection from closest node in above row
            let closest = aboveRow.reduce((best, n) => Math.abs(n.x - node.x) < Math.abs(best.x - node.x) ? n : best, aboveRow[0]);
            networkEdges.push({ a: closest, b: node });
          }
        }
        // Update network info text
        const infoDiv = document.getElementById('network-info');
        if (infoDiv) infoDiv.textContent = `Netzwerk-Reihen: ${totalRows}`;
      }

      function drawNetwork() {
        stroke(100, 100, 100, 120);
        strokeWeight(2);
        for (let edge of networkEdges) {
          line(edge.a.x, edge.a.y, edge.b.x, edge.b.y);
        }
        fill(150, 150, 150, 180);
        noStroke();
        for (let node of networkNodes) {
          ellipse(node.x, node.y, 10, 10);
        }
      }

      window.setup = function() {
        createCanvas(windowWidth, windowHeight);
        background(0);
        angleMode(RADIANS);
        createTriangularNetwork();
      }

      window.windowResized = function() {
        resizeCanvas(windowWidth, windowHeight);
        createTriangularNetwork();
      }

      window.draw = function() {
        background(0, 60);
        drawNetwork();
        for (let i = strokes.length - 1; i >= 0; i--) {
          let s = strokes[i];
          
          s.x += s.vx;
          s.y += s.vy;

          strokeWeight(s.weight);

          const magnitude = sqrt(s.vx * s.vx + s.vy * s.vy);
          const tailX = s.x - (s.vx / magnitude) * s.length;
          const tailY = s.y - (s.vy / magnitude) * s.length;

          const splitPointX = s.x * 0.2 + tailX * 0.8;
          const splitPointY = s.y * 0.2 + tailY * 0.8;

          stroke(s.color1);
          line(s.x, s.y, splitPointX, splitPointY);

          stroke(s.color2);
          line(splitPointX, splitPointY, tailX, tailY);
          
          // Entferne die Linie, wenn sie den Bildschirm verlässt (oben, unten, links oder rechts)
          if (s.y < -s.length || s.y > height + s.length || s.x < -s.length || s.x > width + s.length) { 
            strokes.splice(i, 1); 
          }
        }
      }

      // Funktion zum Hinzufügen einer Linie, angepasst für die neue Logik
      function addStroke(type) {
        let s;

        if (type === 'download') {
          // Download-Striche: Starten oben verteilt und bewegen sich zum Zielpunkt unten mitte
          const speed = random(7, 10);
          const startX = random(width);
          const startY = 0;
          const targetX = width / 2;
          const targetY = height;
          
          // Winkel zum Zielpunkt berechnen
          const angle = atan2(targetY - startY, targetX - startX);

          s = {
            type: 'download',
            x: startX,
            y: startY,
            vx: cos(angle) * speed,
            vy: sin(angle) * speed,
            length: random(15, 30),
            color1: color(random(80, 200), random(50, 150), 255, 200),
            color2: color(random(50, 150), random(30, 100), 230, 220),
            weight: 5
          };
        } else {
          // Tshark-Striche: Behalten ihre alte Logik bei (Start unten mitte, Flug nach oben)
          const speed = random(3, 6);
          const angle = random(-PI * 0.8, -PI * 0.2); // Nach oben gerichteter Winkel

          s = {
            type: 'tshark',
            x: width / 2,
            y: height,
            vx: cos(angle) * speed,
            vy: sin(angle) * speed,
            length: random(20, 40),
            color1: color(random(100, 255), random(100, 255), random(100, 255), 200),
            color2: color(random(100, 255), random(100, 255), random(100, 255), 220),
            weight: 10
          };
        }
        strokes.push(s);
      }
      
      function startDownloadAction() {
        const button = document.getElementById("download-button");
        if(button.disabled) return;
        button.textContent = "Download läuft...";
        button.disabled = true;
        window.location.href = '/start-download';
        setTimeout(() => {
          button.textContent = "Download erneut starten";
          button.disabled = false;
        }, 20000);
      }

      document.getElementById("download-button").addEventListener("click", startDownloadAction);

      const ws = new WebSocket('ws://localhost:3000');
      
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          
          if (msg.type === 'START_DOWNLOAD') {
            startDownloadAction();
          } else if (msg.type === 'tshark-packet') {
            addStroke('tshark');
          } else if (msg.type === 'download-packet') {
            addStroke('download');
          }
        } catch(e) {
          // Ignoriere Nachrichten, die kein valides JSON sind
        }
      };

      ws.onopen = () => console.log("STATUS: WebSocket-Verbindung ist offen.");
    });
  </script>
</body>
</html>