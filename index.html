<!-- index.html (Optimiert mit neuen seitlichen Armen) -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Live Paket Visualisierung mit p5.js</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #download-button {
      position: absolute; bottom: 20px; left: 20px;
      padding: 12px 24px; background: #007bff; color: #fff;
      border: none; border-radius: 8px; font-size: 16px;
      cursor: pointer; z-index: 100;
    }
    #download-button:disabled { background: #555; cursor: not-allowed; }
  </style>
</head>
<body>
  <div id="network-info" style="position:absolute; left:20px; bottom:60px; color:#ccc; font-family:sans-serif; font-size:16px; z-index:101;"></div>
  <button id="download-button">Download starten</button>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof p5 === 'undefined') {
        document.body.innerHTML = '<h1 style="color:red;">Fehler: p5.js konnte nicht geladen werden.</h1>';
        return;
      }
      
      let pathStrokes = [];
      let networkNodes = [];
      let networkEdges = [];
      let TRI_ROWS = 10;

      let lastDownloadStrokeTime = 0;
      const downloadStrokeInterval = 30; 

      /**
       * Erstellt ein breites, semi-organisches Netzwerk mit seitlichen Armen.
       */
      function createTriangularNetwork() {
        networkNodes = [];
        networkEdges = [];
        TRI_ROWS = constrain(Math.round(height / 70), 7, 18);
        let totalRows = TRI_ROWS + 1;
        let yTop = -height / (TRI_ROWS - 1);
        let yBottom = height; 

        // Hauptnetzwerk erstellen
        for (let r = 0; r < totalRows; r++) {
          let t = r / (totalRows - 1);
          let y = lerp(yTop, yBottom, t);
          let nodesInRow = (totalRows - r);
          
          let triangleWidth = width * 0.95; 
          let rowWidth = triangleWidth * (nodesInRow / totalRows);
          let xStart = width / 2 - rowWidth / 2;
          let xStep = (nodesInRow > 1) ? rowWidth / (nodesInRow - 1) : 0;
          
          for (let c = 0; c < nodesInRow; c++) {
            let baseX = (nodesInRow === 1) ? width / 2 : xStart + c * xStep;
            
            let xRandomness = (r === 0 || r === totalRows - 1) ? 0 : random(-width * 0.02, width * 0.02);
            let yRandomness = (r === 0 || r === totalRows - 1) ? 0 : random(-height * 0.01, height * 0.01);

            networkNodes.push({ 
              x: baseX + xRandomness, 
              y: y + yRandomness, 
              r, 
              c 
            });
          }
        }
        
        // Kanten für das Hauptnetzwerk erstellen
        let nodeCounter = 0;
        for (let r = 0; r < totalRows - 1; r++) {
            const nodesInCurrentRow = totalRows - r;
            const nodesInNextRow = totalRows - (r + 1);
            const nextRowStartIndex = nodeCounter + nodesInCurrentRow;

            for (let c = 0; c < nodesInCurrentRow; c++) {
                const parentNode = networkNodes[nodeCounter + c];

                if (c < nodesInNextRow) {
                    const childNode1 = networkNodes[nextRowStartIndex + c];
                    networkEdges.push({ a: parentNode, b: childNode1 });
                }

                if (c > 0) {
                    const childNode2 = networkNodes[nextRowStartIndex + c - 1];
                    networkEdges.push({ a: parentNode, b: childNode2 });
                }
            }
            nodeCounter += nodesInCurrentRow;
        }

        // --- NEU: Gezielte Arme nach links und rechts oben ---
        
        // 1. Alle Randknoten sammeln
        const leftEdgeNodes = [];
        const rightEdgeNodes = [];
        let tempNodeCounter = 0;
        for (let r = 0; r < totalRows; r++) {
          const nodesInRow = totalRows - r;
          if (nodesInRow > 0) {
            leftEdgeNodes.push(networkNodes[tempNodeCounter]);
            if (nodesInRow > 1) {
              rightEdgeNodes.push(networkNodes[tempNodeCounter + nodesInRow - 1]);
            }
          }
          tempNodeCounter += nodesInRow;
        }

        // 2. Randknoten von unten nach oben sortieren
        leftEdgeNodes.sort((a, b) => b.y - a.y);
        rightEdgeNodes.sort((a, b) => b.y - a.y);

        // 3. Arme für die rechte Seite erstellen (beginnend beim 3. Knoten von unten)
        for (let i = 2; i < rightEdgeNodes.length; i++) {
          const originNode = rightEdgeNodes[i];
          const targetNode = {
            x: width,
            y: originNode.y - random(height * 0.1, height * 0.4), // Ziel schräg nach oben
            r: -1, c: -1 // Markierung als externer Knoten
          };
          networkNodes.push(targetNode);
          networkEdges.push({ a: originNode, b: targetNode });
        }

        // 4. Arme für die linke Seite erstellen (beginnend beim 2. Knoten von unten)
        for (let i = 1; i < leftEdgeNodes.length; i++) {
          const originNode = leftEdgeNodes[i];
          const targetNode = {
            x: 0,
            y: originNode.y - random(height * 0.1, height * 0.4), // Ziel schräg nach oben
            r: -1, c: -1 // Markierung als externer Knoten
          };
          networkNodes.push(targetNode);
          networkEdges.push({ a: originNode, b: targetNode });
        }

        const infoDiv = document.getElementById('network-info');
        if (infoDiv) infoDiv.textContent = `Netzwerk-Reihen: ${totalRows}`;
      }

      function drawNetwork() {
        stroke(100, 100, 100, 120);
        strokeWeight(1.5);
        for (let edge of networkEdges) {
          line(edge.a.x, edge.a.y, edge.b.x, edge.b.y);
        }
        fill(150, 150, 150, 180);
        noStroke();
        for (let node of networkNodes) {
          ellipse(node.x, node.y, 8, 8);
        }
      }

      window.setup = function() {
        createCanvas(windowWidth, windowHeight);
        background(0);
        angleMode(RADIANS);
        createTriangularNetwork();
      }

      window.windowResized = function() {
        resizeCanvas(windowWidth, windowHeight);
        createTriangularNetwork();
      }

      window.draw = function() {
        background(0, 60);
        drawNetwork();

        for (let i = pathStrokes.length - 1; i >= 0; i--) {
          let s = pathStrokes[i];
          s.progress += s.speed;

          if (s.progress >= 1) {
            s.currentNode = s.targetNode;
            s.progress = 0;

            let possibleNextEdges = [];
            // Partikel sollen nicht in die Arme abbiegen, daher Filterung nach r != -1
            if (s.type === 'tshark') { 
              possibleNextEdges = networkEdges.filter(e => e.b === s.currentNode && e.a.r !== -1);
            } else { 
              possibleNextEdges = networkEdges.filter(e => e.a === s.currentNode && e.b.r !== -1);
            }

            if (possibleNextEdges.length > 0) {
              const nextEdge = random(possibleNextEdges);
              s.targetNode = (s.type === 'tshark') ? nextEdge.a : nextEdge.b;
            } else {
              pathStrokes.splice(i, 1);
              continue;
            }
          }
          
          const headX = lerp(s.currentNode.x, s.targetNode.x, s.progress);
          const headY = lerp(s.currentNode.y, s.targetNode.y, s.progress);

          const vx = s.targetNode.x - s.currentNode.x;
          const vy = s.targetNode.y - s.currentNode.y;
          const magnitude = sqrt(vx * vx + vy * vy);
          const tailX = headX - (vx / magnitude) * s.length;
          const tailY = headY - (vy / magnitude) * s.length;

          strokeWeight(s.weight);
          const splitPointX = lerp(headX, tailX, 0.8);
          const splitPointY = lerp(headY, tailY, 0.8);

          stroke(s.color1);
          line(headX, headY, splitPointX, splitPointY);

          stroke(s.color2);
          line(splitPointX, splitPointY, tailX, tailY);
        }
      }

      function addStroke(type) {
        if (networkEdges.length === 0) return;

        let startNode, targetNode, initialEdge;

        if (type === 'tshark') {
          const bottomRow = networkNodes.filter(n => n.r === TRI_ROWS);
          if (bottomRow.length === 0) return;
          const startCand = random(bottomRow);
          const parentEdges = networkEdges.filter(e => e.b === startCand);
          if (parentEdges.length === 0) return;

          initialEdge = random(parentEdges);
          startNode = initialEdge.b;
          targetNode = initialEdge.a;
          
          pathStrokes.push({
            type: 'tshark',
            currentNode: startNode,
            targetNode: targetNode,
            progress: 0,
            speed: random(0.03, 0.06),
            length: random(20, 40),
            color1: color(100, 200, 255, 200),
            color2: color(80, 150, 230, 220),
            weight: 2
          });

        } else if (type === 'download') {
          const topRowNodes = networkNodes.filter(n => n.r === 0);
          if (topRowNodes.length === 0) return;
          const topNode = topRowNodes[floor(topRowNodes.length / 2)];
          if (!topNode) return;

          const childEdges = networkEdges.filter(e => e.a === topNode && e.b.r !== -1);
          if (childEdges.length === 0) return;

          initialEdge = random(childEdges);
          startNode = initialEdge.a;
          targetNode = initialEdge.b;

          pathStrokes.push({
            type: 'download',
            currentNode: startNode,
            targetNode: targetNode,
            progress: 0,
            speed: random(0.04, 0.08),
            length: random(15, 30),
            color1: color(255, 180, 80, 200),
            color2: color(230, 150, 50, 220),
            weight: 4
          });
        }
      }
      
      function startDownloadAction() {
        const button = document.getElementById("download-button");
        if(button.disabled) return;
        button.textContent = "Download läuft...";
        button.disabled = true;
        window.location.href = '/start-download';
        setTimeout(() => {
          button.textContent = "Download erneut starten";
          button.disabled = false;
        }, 20000);
      }

      document.getElementById("download-button").addEventListener("click", startDownloadAction);

      const ws = new WebSocket('ws://localhost:3000');
      
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          
          if (msg.type === 'START_DOWNLOAD') {
            startDownloadAction();
          } else if (msg.type === 'tshark-packet') {
            addStroke('tshark');
          } else if (msg.type === 'download-packet') {
            const now = millis();
            if (now - lastDownloadStrokeTime > downloadStrokeInterval) {
              addStroke('download');
              lastDownloadStrokeTime = now;
            }
          }
        } catch(e) {
          // Ignoriert invalide JSON-Nachrichten
        }
      };

      ws.onopen = () => console.log("STATUS: WebSocket-Verbindung ist offen.");
      ws.onerror = (err) => console.error("WebSocket Fehler:", err);
    });
  </script>
</body>
</html>
