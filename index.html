<!-- index.html (Optimiert mit mehr Zufälligkeit) -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Live Paket Visualisierung mit p5.js</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #download-button {
      position: absolute; bottom: 20px; left: 20px;
      padding: 12px 24px; background: #007bff; color: #fff;
      border: none; border-radius: 8px; font-size: 16px;
      cursor: pointer; z-index: 100;
    }
    #download-button:disabled { background: #555; cursor: not-allowed; }
  </style>
</head>
<body>
  <div id="network-info" style="position:absolute; left:20px; bottom:60px; color:#ccc; font-family:sans-serif; font-size:16px; z-index:101;"></div>
  <button id="download-button">Download starten</button>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof p5 === 'undefined') {
        document.body.innerHTML = '<h1 style="color:red;">Fehler: p5.js konnte nicht geladen werden.</h1>';
        return;
      }
      
      let pathStrokes = [];
      let networkNodes = [];
      let networkEdges = [];
      let TRI_ROWS = 9; // Ergibt 10 Reihen

      let lastDownloadStrokeTime = 0;
      const downloadStrokeInterval = 30; 

      /**
       * Erstellt das finale Netzwerk: 10 Reihen, die unten breiter werden, um den Bildschirm zu füllen.
       */
      function createFinalNetwork() {
        networkNodes = [];
        networkEdges = [];
        let totalRows = TRI_ROWS + 1;
        let yTop = -height / (TRI_ROWS);
        let yBottom = height; 

        // Hauptnetzwerk erstellen (von oben nach unten)
        for (let r = 0; r < totalRows; r++) {
          let t = r / (totalRows - 1);
          let y = lerp(yTop, yBottom, t);
          let nodesInRow = (totalRows - r);
          
          let maxWidth = width * 1.1; 
          let scaleFactor = (nodesInRow - 1) / (totalRows - 1);
          let curvedScale = pow(scaleFactor, 0.6); 
          let rowWidth = maxWidth * curvedScale;

          let xStart = width / 2 - rowWidth / 2;
          let xStep = (nodesInRow > 1) ? rowWidth / (nodesInRow - 1) : 0;
          
          for (let c = 0; c < nodesInRow; c++) {
            let baseX = (nodesInRow === 1) ? width / 2 : xStart + c * xStep;
            
            // --- ANPASSUNG: Erhöhte Zufälligkeit für Abstände und Winkel ---
            let xRandomness = (r > 0 && r < totalRows - 1) ? random(-width * 0.05, width * 0.05) : 0;
            let yRandomness = (r > 0 && r < totalRows - 1) ? random(-height * 0.04, height * 0.04) : 0;

            networkNodes.push({ 
              x: baseX + xRandomness, 
              y: y + yRandomness, 
              r, 
              c 
            });
          }
        }
        
        // Kanten für das Hauptnetzwerk erstellen
        let nodeCounter = 0;
        for (let r = 0; r < totalRows - 1; r++) {
            const nodesInCurrentRow = totalRows - r;
            const nodesInNextRow = totalRows - (r + 1);
            const nextRowStartIndex = nodeCounter + nodesInCurrentRow;

            for (let c = 0; c < nodesInCurrentRow; c++) {
                const parentNode = networkNodes[nodeCounter + c];

                if (c < nodesInNextRow) {
                    const childNode1 = networkNodes[nextRowStartIndex + c];
                    networkEdges.push({ a: parentNode, b: childNode1 });
                }

                if (c > 0) {
                    const childNode2 = networkNodes[nextRowStartIndex + c - 1];
                    networkEdges.push({ a: parentNode, b: childNode2 });
                }
            }
            nodeCounter += nodesInCurrentRow;
        }
        
        const infoDiv = document.getElementById('network-info');
        if (infoDiv) infoDiv.textContent = `Netzwerk-Reihen: ${totalRows}`;
      }

      function drawNetwork() {
        stroke(100, 100, 100, 120);
        strokeWeight(1.5);
        for (let edge of networkEdges) {
          line(edge.a.x, edge.a.y, edge.b.x, edge.b.y);
        }
        fill(150, 150, 150, 180);
        noStroke();
        for (let node of networkNodes) {
          ellipse(node.x, node.y, 8, 8);
        }
      }

      window.setup = function() {
        createCanvas(windowWidth, windowHeight);
        background(0);
        angleMode(RADIANS);
        createFinalNetwork();
      }

      window.windowResized = function() {
        resizeCanvas(windowWidth, windowHeight);
        createFinalNetwork();
      }

      window.draw = function() {
        background(0, 60);
        drawNetwork();

        for (let i = pathStrokes.length - 1; i >= 0; i--) {
          let s = pathStrokes[i];
          s.progress += s.speed;

          if (s.progress >= 1) {
            s.currentNode = s.targetNode;
            s.progress = 0;

            let possibleNextEdges = [];
            if (s.type === 'tshark') { 
              possibleNextEdges = networkEdges.filter(e => e.b === s.currentNode);
            } else { 
              possibleNextEdges = networkEdges.filter(e => e.a === s.currentNode);
            }

            if (possibleNextEdges.length > 0) {
              const nextEdge = random(possibleNextEdges);
              s.targetNode = (s.type === 'tshark') ? nextEdge.a : nextEdge.b;
            } else {
              pathStrokes.splice(i, 1);
              continue;
            }
          }
          
          const headX = lerp(s.currentNode.x, s.targetNode.x, s.progress);
          const headY = lerp(s.currentNode.y, s.targetNode.y, s.progress);

          const vx = s.targetNode.x - s.currentNode.x;
          const vy = s.targetNode.y - s.currentNode.y;
          const magnitude = sqrt(vx * vx + vy * vy);
          const tailX = headX - (vx / magnitude) * s.length;
          const tailY = headY - (vy / magnitude) * s.length;

          strokeWeight(s.weight);
          const splitPointX = lerp(headX, tailX, 0.8);
          const splitPointY = lerp(headY, tailY, 0.8);

          stroke(s.color1);
          line(headX, headY, splitPointX, splitPointY);

          stroke(s.color2);
          line(splitPointX, splitPointY, tailX, tailY);
        }
      }

      function addStroke(type) {
        if (networkEdges.length === 0) return;

        let startNode, targetNode, initialEdge;

        if (type === 'tshark') {
          const bottomNode = networkNodes.find(n => n.r === TRI_ROWS);
          if (!bottomNode) return;
          const parentEdges = networkEdges.filter(e => e.b === bottomNode);
          if (parentEdges.length === 0) return;

          initialEdge = random(parentEdges);
          startNode = initialEdge.b;
          targetNode = initialEdge.a;
          
          pathStrokes.push({
            type: 'tshark',
            currentNode: startNode,
            targetNode: targetNode,
            progress: 0,
            speed: random(0.03, 0.06),
            length: random(20, 40),
            color1: color(100, 200, 255, 200),
            color2: color(80, 150, 230, 220),
            weight: 2
          });

        } else if (type === 'download') {
          const topRowNodes = networkNodes.filter(n => n.r === 0);
          if (topRowNodes.length === 0) return;
          const topNode = random(topRowNodes);

          const childEdges = networkEdges.filter(e => e.a === topNode);
          if (childEdges.length === 0) return;

          initialEdge = random(childEdges);
          startNode = initialEdge.a;
          targetNode = initialEdge.b;

          pathStrokes.push({
            type: 'download',
            currentNode: startNode,
            targetNode: targetNode,
            progress: 0,
            speed: random(0.04, 0.08),
            length: random(15, 30),
            color1: color(255, 180, 80, 200),
            color2: color(230, 150, 50, 220),
            weight: 4
          });
        }
      }
      
      function startDownloadAction() {
        const button = document.getElementById("download-button");
        if(button.disabled) return;
        button.textContent = "Download läuft...";
        button.disabled = true;
        window.location.href = '/start-download';
        setTimeout(() => {
          button.textContent = "Download erneut starten";
          button.disabled = false;
        }, 20000);
      }

      document.getElementById("download-button").addEventListener("click", startDownloadAction);

      const ws = new WebSocket('ws://localhost:3000');
      
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          
          if (msg.type === 'START_DOWNLOAD') {
            startDownloadAction();
          } else if (msg.type === 'tshark-packet') {
            addStroke('tshark');
          } else if (msg.type === 'download-packet') {
            const now = millis();
            if (now - lastDownloadStrokeTime > downloadStrokeInterval) {
              addStroke('download');
              lastDownloadStrokeTime = now;
            }
          }
        } catch(e) {
          // Ignoriert invalide JSON-Nachrichten
        }
      };

      ws.onopen = () => console.log("STATUS: WebSocket-Verbindung ist offen.");
      ws.onerror = (err) => console.error("WebSocket Fehler:", err);
    });
  </script>
</body>
</html>
