<!-- index.html (Optimiert zur Behebung von Lags) -->
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Live Paket Visualisierung mit p5.js</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #download-button {
      position: absolute; bottom: 20px; left: 20px;
      padding: 12px 24px; background: #007bff; color: #fff;
      border: none; border-radius: 8px; font-size: 16px;
      cursor: pointer; z-index: 100;
    }
    #download-button:disabled { background: #555; cursor: not-allowed; }
  </style>
</head>
<body>
  <div id="network-info" style="position:absolute; left:20px; bottom:60px; color:#ccc; font-family:sans-serif; font-size:16px; z-index:101;"></div>
  <button id="download-button">Download starten</button>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      if (typeof p5 === 'undefined') {
        document.body.innerHTML = '<h1 style="color:red;">Fehler: p5.js konnte nicht geladen werden.</h1>';
        return;
      }
      
      let particlePool = [];
      const MAX_PARTICLES = 700; 

      let networkNodes = [];
      let networkEdges = [];
      let TRI_ROWS = 9; 

      let lastDownloadStrokeTime = 0;
      const downloadStrokeInterval = 40; // Intervall leicht erhöht, um die Last zu reduzieren

      function createFinalNetwork() {
        networkNodes = [];
        networkEdges = [];
        let totalRows = TRI_ROWS + 1;
        let yTop = -height / (TRI_ROWS);
        let yBottom = height; 

        for (let r = 0; r < totalRows; r++) {
          let t = r / (totalRows - 1);
          let y = lerp(yTop, yBottom, t);
          let nodesInRow = (totalRows - r);
          
          let maxWidth = width * 1.1; 
          let scaleFactor = (nodesInRow - 1) / (totalRows - 1);
          let curvedScale = pow(scaleFactor, 0.6); 
          let rowWidth = maxWidth * curvedScale;

          let xStart = width / 2 - rowWidth / 2;
          let xStep = (nodesInRow > 1) ? rowWidth / (nodesInRow - 1) : 0;
          
          for (let c = 0; c < nodesInRow; c++) {
            let baseX = (nodesInRow === 1) ? width / 2 : xStart + c * xStep;
            
            let xRandomness = (r > 0 && r < totalRows - 1) ? random(-width * 0.05, width * 0.05) : 0;
            let yRandomness = (r > 0 && r < totalRows - 1) ? random(-height * 0.04, height * 0.04) : 0;

            networkNodes.push({ 
              x: baseX + xRandomness, 
              y: y + yRandomness, 
              r, 
              c 
            });
          }
        }
        
        let nodeCounter = 0;
        for (let r = 0; r < totalRows - 1; r++) {
            const nodesInCurrentRow = totalRows - r;
            const nodesInNextRow = totalRows - (r + 1);
            const nextRowStartIndex = nodeCounter + nodesInCurrentRow;

            for (let c = 0; c < nodesInCurrentRow; c++) {
                const parentNode = networkNodes[nodeCounter + c];

                if (c < nodesInNextRow) {
                    const childNode1 = networkNodes[nextRowStartIndex + c];
                    networkEdges.push({ a: parentNode, b: childNode1 });
                }

                if (c > 0) {
                    const childNode2 = networkNodes[nextRowStartIndex + c - 1];
                    networkEdges.push({ a: parentNode, b: childNode2 });
                }
            }
            nodeCounter += nodesInCurrentRow;
        }

        const bottomNode = networkNodes.find(n => n.r === TRI_ROWS);
        const targetRow = networkNodes.filter(n => n.r === TRI_ROWS - 2); 
        if (bottomNode && targetRow.length > 0) {
            const middleNodeAbove = targetRow[Math.floor(targetRow.length / 2)];
            if (middleNodeAbove) {
                 networkEdges.push({ a: middleNodeAbove, b: bottomNode });
            }
        }
        
        const infoDiv = document.getElementById('network-info');
        if (infoDiv) infoDiv.textContent = `Netzwerk-Reihen: ${totalRows}`;
      }

      function drawNetwork() {
        stroke(100, 100, 100, 120);
        strokeWeight(1.5);
        for (let edge of networkEdges) {
          line(edge.a.x, edge.a.y, edge.b.x, edge.b.y);
        }
        fill(150, 150, 150, 180);
        noStroke();
        for (let node of networkNodes) {
          ellipse(node.x, node.y, 10, 10);
        }
      }

      window.setup = function() {
        createCanvas(windowWidth, windowHeight);
        background(0);
        angleMode(RADIANS);

        // Particle Pool wird initialisiert, jedes Partikel bekommt eine Pfad-Historie
        for (let i = 0; i < MAX_PARTICLES; i++) {
          particlePool.push({ isActive: false, path: [] });
        }

        createFinalNetwork();
      }

      window.windowResized = function() {
        resizeCanvas(windowWidth, windowHeight);
        createFinalNetwork();
      }

      window.draw = function() {
        background(0, 60);
        drawNetwork();

        for (const s of particlePool) {
          if (!s.isActive) continue;

          s.progress += s.speed;

          // Knotenwechsel-Logik
          if (s.progress >= 1) {
            s.currentNode = s.targetNode;
            s.progress = 0;
            s.path.push({x: s.currentNode.x, y: s.currentNode.y}); // Letzten Punkt des alten Pfades hinzufügen

            let possibleNextEdges = [];
            if (s.type === 'tshark') { 
              possibleNextEdges = networkEdges.filter(e => e.b === s.currentNode);
            } else { 
              possibleNextEdges = networkEdges.filter(e => e.a === s.currentNode);
            }

            if (possibleNextEdges.length > 0) {
              const nextEdge = random(possibleNextEdges);
              s.targetNode = (s.type === 'tshark') ? nextEdge.a : nextEdge.b;
            } else {
              s.isActive = false;
              continue;
            }
          }
          
          const headX = lerp(s.currentNode.x, s.targetNode.x, s.progress);
          const headY = lerp(s.currentNode.y, s.targetNode.y, s.progress);

          // Neue Position am Anfang des Pfades hinzufügen
          s.path.unshift({x: headX, y: headY});

          // Pfad auf die maximale Länge kürzen
          if (s.path.length > s.length) {
            s.path.pop();
          }

          // --- ÜBERARBEITETE, PERFORMANTE ZEICHENLOGIK ---
          // Zeichnet den Partikel-Schweif als eine Kette von kurzen, gefärbten Liniensegmenten.
          noFill();
          for (let i = 0; i < s.path.length - 1; i++) {
            const p1 = s.path[i];
            const p2 = s.path[i + 1];
            
            // Berechne das Verhältnis für den Farb- und Dickenverlauf
            const ratio = i / (s.path.length - 1);
            
            const strokeColor = lerpColor(s.color1, s.color2, ratio);
            const sw = lerp(s.weight, s.weight * 0.2, ratio);
            
            stroke(strokeColor);
            strokeWeight(sw);
            line(p1.x, p1.y, p2.x, p2.y);
          }
        }
      }

      function spawnParticle(type) {
        if (networkEdges.length === 0) return;

        const particle = particlePool.find(p => !p.isActive);
        if (!particle) return;

        let startNode, targetNode, initialEdge;

        if (type === 'tshark') {
          const bottomNode = networkNodes.find(n => n.r === TRI_ROWS);
          if (!bottomNode) return;
          const parentEdges = networkEdges.filter(e => e.b === bottomNode);
          if (parentEdges.length === 0) return;

          initialEdge = random(parentEdges);
          startNode = initialEdge.b;
          targetNode = initialEdge.a;
          
          Object.assign(particle, {
            isActive: true, type: 'tshark', currentNode: startNode, targetNode: targetNode,
            progress: 0, speed: random(0.03, 0.06), 
            length: floor(random(10, 18)), 
            color1: color(100, 200, 255, 200), color2: color(80, 150, 230, 50), weight: 5,
            path: [{x: startNode.x, y: startNode.y}]
          });

        } else if (type === 'download') {
          const topRowNodes = networkNodes.filter(n => n.r === 0);
          if (topRowNodes.length === 0) return;
          const topNode = random(topRowNodes);

          const childEdges = networkEdges.filter(e => e.a === topNode);
          if (childEdges.length === 0) return;

          initialEdge = random(childEdges);
          startNode = initialEdge.a;
          targetNode = initialEdge.b;

          Object.assign(particle, {
            isActive: true, type: 'download', currentNode: startNode, targetNode: targetNode,
            progress: 0, speed: random(0.04, 0.08), 
            length: floor(random(8, 15)),
            color1: color(255, 180, 80, 220), color2: color(230, 150, 50, 50), weight: 6,
            path: [{x: startNode.x, y: startNode.y}]
          });
        }
      }
      
      function startDownloadAction() {
        const button = document.getElementById("download-button");
        if(button.disabled) return;
        button.textContent = "Download läuft...";
        button.disabled = true;
        window.location.href = '/start-download';
        setTimeout(() => {
          button.textContent = "Download erneut starten";
          button.disabled = false;
        }, 20000);
      }

      document.getElementById("download-button").addEventListener("click", startDownloadAction);

      const ws = new WebSocket('ws://localhost:3000');
      
      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          
          if (msg.type === 'START_DOWNLOAD') {
            startDownloadAction();
          } else if (msg.type === 'tshark-packet') {
            spawnParticle('tshark');
          } else if (msg.type === 'download-packet') {
            const now = millis();
            if (now - lastDownloadStrokeTime > downloadStrokeInterval) {
              spawnParticle('download');
              lastDownloadStrokeTime = now;
            }
          }
        } catch(e) {
          // Ignoriert invalide JSON-Nachrichten
        }
      };

      ws.onopen = () => console.log("STATUS: WebSocket-Verbindung ist offen.");
      ws.onerror = (err) => console.error("WebSocket Fehler:", err);
    });
  </script>
</body>
</html>
